/**
 * Created by wangchen on 2017/8/11.
 * --------------------
 * - 树型数据结构 -
 * --------------------
 * 实现树型的数据结构，用于方便在菜单、tree、treegrid等控件中使用
 */

/**
 * 树中的结点
 */
class Node {
    constructor(data) {
        this.data = data;
        this.parent = null;
        this.children = [];
        // this.level = 1;
    }

    addChildren(node){
        this.children.push(node);
        node.parent = this;
        // node.level = this.level +1;
        //node.countLevel(++this.level);
    }

    removeChildren(node){
        node.parent = null;
        let childrens = this.children;
        let newChildrens = childrens.filter(item=>item!=node);
        childrens.length = 0;
        this.children = newChildrens;
    }

   /* countLevel(level){
        this.level = level;
        if(this.children.length>0){
            for (let child of this.children) {
                child.countLevel((++this.level));
            }
        }
    }*/
   
}

 class Tree {

    constructor(option) {
        this.root = new Node(option.data);
        this.dataParentId = option.dataParentId;
        this.dataId = option.dataId;
        this.virtualNode = []; //存储没有找到父节点的元素
    }

    //深度遍历
    deepTraversal(callback, node) {
        var nodes = [];
        if (node != null) {
            var stack = [];
            stack.push(node);
            while (stack.length != 0) {
                var item = stack.pop();
                callback(item);
                nodes.push(item);
                var children = item.children;
                for (var i = children.length - 1; i >= 0; i--)
                    stack.push(children[i]);
            }
        }
        return nodes;
    }

    //广度遍历
    wideTraversal(callback, node) {
        var nodes = [];
        if (node != null) {
            var queue = [];
            queue.unshift(node);
            while (queue.length != 0) {
                var item = queue.shift();
                callback(item);
                nodes.push(item);
                var children = item.children;
                for (var i = 0; i < children.length; i++)
                    queue.push(children[i]);
            }
        }
        return nodes;
    }

    contains(callback, traversal, node) {
        traversal.call(this, callback, node);
    }

    add() {
        if (arguments.length == 3) {
            this.addTargetObj(arguments[0], arguments[1], arguments[2]);
        } else {
            this.addAutoFindParent(arguments[0], arguments[1]);
        }
    }

    addTargetObj(data, toData, traversal) {
        let child = new Node(data),
            parent = null,
            callback = (node) => {
                if (this.equals(node.data, toData)) {
                    // if (node.data.id== toData.id) {
                    parent = node;
                }
            };

        this.contains(callback, traversal, this.root);

        if (parent) {
           /* parent.children.push(child);
            child.parent = parent;*/
            parent.addChildren(child);
        } else {
            thrownewError('Cannot add node to a non-existent parent.');
        }
    }
    //挂接到tree中正确的节点位置
    addAutoFindParent(data, traversal) {
        let currNode = new Node(data),
            parent = null,
            childNode = [],
            callback = (node) => {
                if (node.data[this.dataId] == data[this.dataParentId]) { //找到父节点
                    parent = node;
                } else if (node.data[this.dataParentId] == data[this.dataId]) { //如果是子节点
                    childNode.push(node);
                } else {
                    return null;
                }
                return node;

            };
        this.contains(callback, traversal, this.root);
        for (let i = 0; i < this.virtualNode.length; i++) {
            if (this.virtualNode[i] != null) {
                let n = callback(this.virtualNode[i]);
                if (n != null) {
                    this.virtualNode[i] = null;
                }
            }

        }
        if (parent) {
            let children = parent.children;
            for (let child of children) { //检查parent节点下的子节点的parent是否需要重新指向当前结点
                if (child.data[this.dataParentId] == data[this.dataId]) {
                    childNode.push(child);
                }
            }
            /*parent.children.push(currNode);
            currNode.parent = parent;*/
            parent.addChildren(currNode);
        } else {
            //thrownewError('Cannot add node to a non-existent parent.');
        }

        let lastRoot = this.root;
        if (childNode.length > 0) {
            for (let node of childNode) {
                if (node.parent != null) {
                    // node.parent.children.pop(node);
                    node.parent.removeChildren(node);
                }

                /*node.parent = currNode;
                currNode.children.push(node);*/
                currNode.addChildren(node);
                if (node == this.root) {
                    this.root = currNode;
                    while (this.root.parent != null) {
                        this.root = this.root.parent;
                    }
                }
            }

            /*if(lastRoot != this.root){
                this.root.countLevel(1);
            }*/

        }

        if (parent == null) { //如果目前没有找到父节点，同时又不是root，则先挂到root下
            if (currNode != this.root) {
                this.virtualNode.push(currNode);
            }
        }
    }


    remove(data, fromData, traversal) {
        var tree = this,
            parent = null,
            childToRemove = null,
            index;

        var callback = (node) => {
            if (this.equals(node.data, fromData)) {
                parent = node;
            }
        };

        this.contains(callback, traversal, this.root);

        if (parent) {
            index = this.findIndex(parent.children, data);

            if (index === undefined) {
                thrownewError('Node to remove does not exist.');
            } else {
                childToRemove = parent.children.splice(index, 1);
            }
        } else {
            thrownewError('Parent does not exist.');
        }

        return childToRemove;
    }

    equals(obj1, obj2) {
        return obj1[this.dataId] == obj2[this.dataId];
    }

    findIndex(nodes, data) {
        for (let i = 0; i < nodes.length; i++) {
            if (nodes[i].data[this.dataId] = data[this.dataId]) {
                return i;
            }
        }
        return;
    }

}

export {
    Tree as
    default, Node as TreeNode
}


